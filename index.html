<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Accéléromètre ESP8266</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@4.1.1/dist/chartjs-plugin-annotation.min.js"></script>
  <script> 
	Chart.register(window['chartjs-plugin-annotation']); 
  </script>
  <style>
    body { font-family: 'Roboto', sans-serif; background: #f5f5f7; color: #222; margin: 0; }
    header { background: #1976d2; color: #fff; padding: 16px; font-size: 1.2em; display: flex; align-items: center; justify-content: center;}
    .container { display: flex; flex-direction: column; align-items: center; margin: 28px 0;}
    .controls { display: flex; gap: 16px; margin-bottom: 22px;}
    .servo-controls label { display:flex; align-items:center; gap:8px; height: 40px; padding: auto;}
    button { padding: auto; font-size: 1.1em; height: 40px; background: #1976d2; color: #fff; border: none; border-radius: 25px; cursor: pointer; transition: background .2s; box-shadow: 0 2px 4px rgba(0,0,0,0.07);}
    button:active, button:focus { background: #0d47a1; outline: none;}
    #status { display: flex; align-items: center; gap: 8px; font-size: 1em; margin-bottom: 16px;}
    #status .material-icons { font-size: 1.2em;}
    #chart-container { width: 98vw; max-width: 1280px; min-width: 300px; max-height: 680px; background: #fff; border-radius: 15px; box-shadow: 0 4px 18px rgba(25,118,210,.08); padding: 16px;}
	#accChart {width: 100%; height: 100%; }
  </style>
</head>
<body>
  <header>
    <span class="material-icons">sensors</span>
    &nbsp;Accéléromètre ESP8266 - Temps d'Arrêt
  </header>
  <div class="container">
    <div id="status">
      <span class="material-icons" id="status-icon">sync</span>
      <span id="status-text">Connexion...</span>
    </div>
    <div class="controls">
		  <label><input type="checkbox" id="cbX" checked> X</label>
		  <label><input type="checkbox" id="cbY" checked> Y</label>
		  <label><input type="checkbox" id="cbZ" checked> Z</label>
		  <button id="startBtn"><span class="material-icons">play_arrow</span> Démarrer</button>
		  <button id="stopBtn" disabled><span class="material-icons">stop</span> Arrêter</button>
		  <div class="controls servo-controls">
			<button id="servo45Btn">Servo 45&deg;</button>
			<button id="servo0Btn">Servo 0&deg;</button>
			<label>Trim: <input type="range" id="trimSlider" min="-30" max="30" value="0" step="1"><span id="trimVal">0&deg;</span></label>
		  </div>
    </div>
    <div id="chart-container">
      <canvas id="accChart" ></canvas>
	  <div id="time-result" style="margin-top:18px; font-size:1.15em; font-weight:500; color:#1976d2;">
		Sélectionnez deux points sur le graphique pour mesurer le temps.
	  </div>
    </div>
  </div>

<script>
let ws;
let chartData = {
  labels: [],
  datasets: [
    {label: 'X', borderWidth:2, data: [], borderColor:'#d32f2f', backgroundColor:'rgba(211,47,47,0.09)', fill:false},
    {label: 'Y', borderWidth:2, data: [], borderColor:'#388e3c', backgroundColor:'rgba(56,142,60,0.09)', fill:false},
    {label: 'Z', borderWidth:2, data: [], borderColor:'#1976d2', backgroundColor:'rgba(25,118,210,0.09)', fill:false},
  ]
};
let maxPoints = 150;
let selectedAxes = "XYZ";

// ==== Curseurs de sélection ====
let cursorA = null, cursorB = null;
let draggingCursor = null; // 'A' ou 'B'

function formatDuration(ms) {
  if (ms < 1000) return ms + " ms";
  if (ms < 60000) return (ms/1000).toFixed(2) + " s";
  let min = Math.floor(ms/60000), sec = ((ms%60000)/1000).toFixed(1);
  return min + " min " + sec + " s";
}

function updateStatus(text, icon, color) {
  document.getElementById('status-text').textContent = text;
  let ic = document.getElementById('status-icon');
  ic.textContent = icon;
  ic.style.color = color || "#1976d2";
}

function connectWS() {
  const ESP_IP = "192.168.4.1";
  ws = new WebSocket('ws://' + ESP_IP + ':81/');
  ws.onopen = function() {
    updateStatus("Connecté", "check_circle", "#388e3c");
    document.getElementById('startBtn').disabled = false;
    document.getElementById('stopBtn').disabled = true;
  };
  ws.onclose = function() {
    updateStatus("Déconnecté", "error_outline", "#d32f2f");
    document.getElementById('startBtn').disabled = true;
    document.getElementById('stopBtn').disabled = true;
    setTimeout(connectWS, 2000);
  };
  ws.onerror = function(e) {
    updateStatus("Erreur WS", "error_outline", "#d32f2f");
  };
  ws.onmessage = function(evt) {
    try {
      let d = evt.data.trim();
      if (d.includes(";")) {
        let parts = d.replace('\n','').split(';');
        if (parts.length >= selectedAxes.length + 1) {
          let t = Number(parts[0]);
          let values = parts.slice(1, 1 + selectedAxes.length).map(Number);
          addData(t, values);
        }
      }
    } catch(e) { /* ignore parse errors */ }
  };
}
function addData(t, values) {
  chartData.labels.push(t);
  let map = {X:null, Y:null, Z:null};
  for(let i=0;i<selectedAxes.length;i++) {
    map[selectedAxes[i]] = values[i];
  }
  chartData.datasets[0].data.push(map.X);
  chartData.datasets[1].data.push(map.Y);
  chartData.datasets[2].data.push(map.Z);
  if (chartData.labels.length > maxPoints) {
    chartData.labels.shift();
    chartData.datasets.forEach(ds => ds.data.shift());
  }
  accChart.update('none');
}

function setCursorsToExtremes() {
  if (chartData.labels.length >= 2) {
    cursorA = chartData.labels[0];
    cursorB = chartData.labels[chartData.labels.length-1];
    updateAnnotations();
    updateTimeResult();
  }
}

function updateAnnotations() {
  accChart.options.plugins.annotation.annotations = {};
  if (cursorA !== null) {
    accChart.options.plugins.annotation.annotations.cursorA = {
      type: 'line',
      xScaleID: 'x',
      yScaleID: 'y',
      xMin: cursorA,
      xMax: cursorA,
      yMin: accChart.scales.y.min,
      yMax: accChart.scales.y.max,
      borderColor: '#fbc02d',
      borderWidth: 2,
      label: {
        enabled: true,
        content: 'A',
        backgroundColor: 'rgba(251,192,45,0.8)',
        position: "start"
      }
    };
  }
  if (cursorB !== null) {
    accChart.options.plugins.annotation.annotations.cursorB = {
      type: 'line',
      xScaleID: 'x',
      yScaleID: 'y',
      xMin: cursorB,
      xMax: cursorB,
      yMin: accChart.scales.y.min,
      yMax: accChart.scales.y.max,
      borderColor: '#43a047',
      borderWidth: 2,
      label: {
        enabled: true,
        content: 'B',
        backgroundColor: 'rgba(67,160,71,0.8)',
        position: "start"
      }
    };
  }
  accChart.update();
}

function updateTimeResult() {
  let t1 = cursorA, t2 = cursorB;
  if (t1 != null && t2 != null) {
    let dt = Math.abs(t2 - t1);
    document.getElementById('time-result').textContent =
      "Δt entre A et B : " + formatDuration(dt);
  } else {
    document.getElementById('time-result').textContent = "Sélectionnez deux points sur le graphique.";
  }
}

window.onload = function() {
  accChart = new Chart(document.getElementById('accChart'), {
    type: 'line',
    data: chartData,
    options: {
      animation: false,
      responsive: true,
      scales: {
        x: { display: true, title: {display:true,text:'Temps (ms)'}, type: 'linear' },
        y: { display: true, title: {display:true,text:'Accélération (g)'} }
      },
      plugins: {
        legend: { position:'top' },
        annotation: { annotations: {} }
      },
      onClick: function(e) {
        // Ajout : clique pour placer ou déplacer les curseurs
        let xVal = accChart.scales.x.getValueForPixel(e.x || e.offsetX);
        // Trouver la valeur de temps la plus proche dans labels
        let closest = chartData.labels.reduce((prev, curr) => Math.abs(curr - xVal) < Math.abs(prev - xVal) ? curr : prev, chartData.labels[0]);
        if (draggingCursor === 'A' || draggingCursor === null) {
          cursorA = closest;
          draggingCursor = 'B';
        } else {
          cursorB = closest;
          draggingCursor = null;
        }
        updateAnnotations();
        updateTimeResult();
      }
    }
  });
  connectWS();
  document.getElementById('startBtn').onclick = function() {
    const cbX = document.getElementById('cbX');
    const cbY = document.getElementById('cbY');
    const cbZ = document.getElementById('cbZ');
    selectedAxes = '';
    if(cbX.checked) selectedAxes += 'X';
    if(cbY.checked) selectedAxes += 'Y';
    if(cbZ.checked) selectedAxes += 'Z';
    ws && ws.send('start:' + selectedAxes);
    this.disabled = true;
    document.getElementById('stopBtn').disabled = false;
    chartData.datasets[0].hidden = !cbX.checked;
    chartData.datasets[1].hidden = !cbY.checked;
    chartData.datasets[2].hidden = !cbZ.checked;
    // Efface curseurs/mesure
    cursorA = null; cursorB = null; draggingCursor = null;
    updateAnnotations(); updateTimeResult();
  };
  document.getElementById('stopBtn').onclick = function() {
    ws && ws.send('stop');
    this.disabled = true;
    document.getElementById('startBtn').disabled = false;
    // Place les curseurs automatiquement sur les extrémités après arrêt
    setTimeout(setCursorsToExtremes, 400); // délai pour laisser finir la réception
  };
  document.getElementById('servo45Btn').onclick = function() {
    ws && ws.send('servo:45');
  };
  document.getElementById('servo0Btn').onclick = function() {
    ws && ws.send('servo:0');
  };
  const trimSlider = document.getElementById('trimSlider');
  const trimVal = document.getElementById('trimVal');
  trimSlider.oninput = function() {
    trimVal.textContent = this.value + '\u00b0';
    ws && ws.send('trim:' + this.value);
  };
};

</script>
</body>
</html>
